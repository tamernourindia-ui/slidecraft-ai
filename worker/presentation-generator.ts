import OpenAI from 'openai';
import pdf from 'pdf-parse';
import PptxGenJS from 'pptxgenjs';
import type { Env } from './core-utils';
import type { GenerationSettings, ColorTheme } from '../src/lib/types';
type BackendGenerationSettings = Omit<GenerationSettings, 'pdfFile'>;
interface SlideData {
  slide_number: number;
  title: string;
  content: string;
  key_points: string[];
}
async function extractPdfData(file: File): Promise<{ text: string; numPages: number }> {
  const buffer = await file.arrayBuffer();
  const data = await pdf(Buffer.from(buffer));
  return { text: data.text, numPages: data.numpages };
}
function getThemeColors(theme: ColorTheme) {
  const themes = {
    high_contrast: {
      bg: 'FFFFFF',
      titleColor: '000000',
      bodyColor: '323232',
      accent: '003366',
    },
    professional: {
      bg: 'F0F5FA',
      titleColor: '003366',
      bodyColor: '282828',
      accent: '0066CC',
    },
    dark: {
      bg: '2D2D30',
      titleColor: 'FFFFFF',
      bodyColor: 'DCDCDC',
      accent: '64C8FF',
    },
  };
  return themes[theme] || themes.professional;
}
async function generatePresentationVersion(slides: SlideData[], settings: BackendGenerationSettings): Promise<Blob> {
  const pres = new PptxGenJS();
  pres.layout = 'LAYOUT_16x9';
  const theme = getThemeColors(settings.colorTheme);
  // Title Slide
  const titleSlide = pres.addSlide();
  titleSlide.background = { color: theme.bg };
  titleSlide.addText(settings.paperName, {
    x: 0.5,
    y: 2.5,
    w: '90%',
    h: 1,
    align: 'center',
    fontSize: 36,
    fontFace: settings.englishFont,
    bold: true,
    color: theme.titleColor,
  });
  titleSlide.addText('Generated by SlideCraft AI', {
    x: 0.5,
    y: 3.5,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 18,
    fontFace: settings.englishFont,
    color: theme.accent,
  });
  // Content Slides
  for (const slideData of slides) {
    const slide = pres.addSlide();
    slide.background = { color: theme.bg };
    slide.addText(slideData.title, {
      x: 0.5,
      y: 0.25,
      w: '90%',
      h: 0.75,
      fontSize: settings.fontSize + 8,
      fontFace: settings.farsiFont,
      bold: true,
      color: theme.titleColor,
    });
    let contentY = 1.2;
    if (slideData.content) {
        const contentBox = slide.addText(slideData.content, {
            x: 0.5,
            y: contentY,
            w: '90%',
            h: 2.5,
            fontSize: settings.fontSize,
            fontFace: settings.farsiFont,
            color: theme.bodyColor,
            lineSpacing: settings.fontSize + 8,
        });
        contentY += (contentBox.h || 0) + 0.2;
    }
    if (slideData.key_points && slideData.key_points.length > 0) {
      slide.addText(
        slideData.key_points.map((point) => ({ text: point, options: { breakLine: true } })),
        {
          x: 0.7,
          y: contentY,
          w: '85%',
          h: 3,
          fontSize: settings.fontSize - 2,
          fontFace: settings.farsiFont,
          color: theme.bodyColor,
          bullet: true,
          lineSpacing: settings.fontSize + 6,
        }
      );
    }
  }
  return pres.write('blob');
}
async function generatePresenterVersion(slides: SlideData[], settings: BackendGenerationSettings): Promise<Blob> {
  const pres = new PptxGenJS();
  pres.layout = 'LAYOUT_16x9';
  for (const slideData of slides) {
    const slide = pres.addSlide();
    slide.background = { color: 'FFFFFF' };
    slide.addText(slideData.title, {
      x: 0.5,
      y: 0.25,
      w: '90%',
      h: 1,
      fontSize: 32,
      fontFace: settings.farsiFont,
      bold: true,
      color: '000000',
    });
    const contentParts = [];
    if (slideData.content) contentParts.push(slideData.content);
    if (slideData.key_points) contentParts.push(...slideData.key_points);
    slide.addText(contentParts.join('\n\n'), {
      x: 0.5,
      y: 1.5,
      w: '90%',
      h: 5.5,
      fontSize: 20,
      fontFace: settings.farsiFont,
      color: '333333',
    });
    const notes = `
SPEAKER NOTES FOR: "${slideData.title}"
Main Point:
${slideData.content}
Key Talking Points:
${slideData.key_points.map((p) => `â€¢ ${p}`).join('\n')}
---
Generated by SlideCraft AI
    `;
    slide.addNotes(notes);
  }
  return pres.write('blob');
}
function createSummarizationPrompt(text: string, settings: BackendGenerationSettings): string {
  const summaryRatios = { low: 0.3, medium: 0.5, high: 0.7 };
  const ratio = summaryRatios[settings.summarizationLevel];
  return `
You are an expert academic researcher. Summarize the following scientific article text and structure it for a PowerPoint presentation.
**Article Name:** ${settings.paperName}
**Target Number of Slides:** ${settings.numSlides}
**Summarization Detail Level:** ${settings.summarizationLevel} (Summarize to approx. ${ratio * 100}% of original content)
**Instructions:**
1. Read the article text.
2. Summarize the content, maintaining scientific accuracy.
3. Divide the summary into ${settings.numSlides} logical sections for slides.
4. For each slide, provide a concise title, the main content body, and 3-5 bullet points (key_points).
5. Return the output as a single, valid JSON object. Do not include any text or markdown formatting before or after the JSON object.
**JSON Output Format:**
{
  "slides": [
    {
      "slide_number": 1,
      "title": "Slide Title",
      "content": "Summarized content for this slide.",
      "key_points": ["Key point 1", "Key point 2", "Key point 3"]
    }
  ]
}
**Article Text (first 30k chars):**
---
${text.substring(0, 30000)}
---
`;
}
export async function generatePresentation(formData: FormData, env: Env) {
  try {
    const file = formData.get('pdfFile') as File;
    const settings: BackendGenerationSettings = {
      paperName: formData.get('paperName') as string,
      numSlides: Number(formData.get('numSlides')),
      summarizationLevel: formData.get('summarizationLevel') as 'low' | 'medium' | 'high',
      farsiFont: formData.get('farsiFont') as any,
      englishFont: formData.get('englishFont') as any,
      fontSize: Number(formData.get('fontSize')),
      colorTheme: formData.get('colorTheme') as any,
    };
    if (!file) throw new Error('PDF file is missing.');
    const { text: extractedText, numPages } = await extractPdfData(file);
    const prompt = createSummarizationPrompt(extractedText, settings);
    const openai = new OpenAI({ baseURL: env.CF_AI_BASE_URL, apiKey: env.CF_AI_API_KEY });
    const response = await openai.chat.completions.create({
      model: 'google-ai-studio/gemini-2.5-flash',
      messages: [{ role: 'user', content: prompt }],
      response_format: { type: 'json_object' },
      temperature: 0.5,
    });
    const aiContent = response.choices[0].message.content;
    if (!aiContent) throw new Error('AI returned an empty response.');
    const summarizedData = JSON.parse(aiContent) as { slides: SlideData[] };
    if (!summarizedData.slides || !Array.isArray(summarizedData.slides)) {
      throw new Error('AI returned data in an invalid format.');
    }
    const [presentationBlob, presenterBlob] = await Promise.all([
      generatePresentationVersion(summarizedData.slides, settings),
      generatePresenterVersion(summarizedData.slides, settings),
    ]);
    const generationResult = {
      statistics: {
        source: settings.paperName,
        field: 'AI Detected Field',
        pdfPages: numPages,
        slides: summarizedData.slides.length,
        summaryLevel: `${settings.summarizationLevel} (${{ low: '30%', medium: '50%', high: '70%' }[settings.summarizationLevel]})`,
        duration: 'N/A',
        translationQuality: 'Expert PhD',
      },
      presentationBlob,
      presenterBlob,
      filename: settings.paperName.replace(/[^a-z0-9]/gi, '_').toLowerCase()
    };
    return { success: true, data: generationResult };
  } catch (error) {
    console.error('Error in presentation generation:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return { success: false, error: `Generation failed: ${errorMessage}` };
  }
}