import pdf from 'pdf-parse';
import PptxGenJS from 'pptxgenjs';
import type { Env } from './core-utils';
import type { GenerationSettings, ColorTheme } from '../src/lib/types';
type BackendGenerationSettings = Omit<GenerationSettings, 'pdfFile'> & { selectedModel: string };
interface SlideData {
  slide_number: number;
  title: string;
  content: string;
  key_points: string[];
}
interface TranslatedSlideData {
  title_en: string;
  content_en: string;
  key_points_en: string[];
  title_fa: string;
  content_fa: string;
  key_points_fa: string[];
}
async function extractPdfData(file: File): Promise<{ text: string; numPages: number }> {
  const buffer = await file.arrayBuffer();
  const data = await pdf(Buffer.from(buffer));
  return { text: data.text, numPages: data.numpages };
}
function getThemeColors(theme: ColorTheme) {
  const themes = {
    high_contrast: {
      bg: 'FFFFFF',
      titleColor: '000000',
      bodyColor: '323232',
      accent: '003366',
    },
    professional: {
      bg: 'F0F5FA',
      titleColor: '003366',
      bodyColor: '282828',
      accent: '0066CC',
    },
    dark: {
      bg: '2D2D30',
      titleColor: 'FFFFFF',
      bodyColor: 'DCDCDC',
      accent: '64C8FF',
    },
  };
  return themes[theme] || themes.professional;
}
async function generatePresentationVersion(slides: TranslatedSlideData[], settings: BackendGenerationSettings): Promise<Blob> {
  const pres = new PptxGenJS();
  pres.layout = 'LAYOUT_16x9';
  const theme = getThemeColors(settings.colorTheme);
  // Title Slide
  const titleSlide = pres.addSlide();
  titleSlide.background = { color: theme.bg };
  titleSlide.addText(settings.paperName, {
    x: 0.5, y: 2.5, w: '90%', h: 1, align: 'center', fontSize: 36, fontFace: settings.englishFont, bold: true, color: theme.titleColor,
  });
  titleSlide.addText('Generated by SlideCraft AI', {
    x: 0.5, y: 3.5, w: '90%', h: 0.5, align: 'center', fontSize: 18, fontFace: settings.englishFont, color: theme.accent,
  });
  // Content Slides
  for (const slideData of slides) {
    const slide = pres.addSlide();
    slide.background = { color: theme.bg };
    slide.transition = { type: 'fade' };
    slide.addText(slideData.title_fa, {
      x: 0.5, y: 0.25, w: '90%', h: 0.75, fontSize: settings.fontSize + 8, fontFace: settings.farsiFont, bold: true, color: theme.titleColor,
    });
    if (slideData.content_fa) {
      slide.addText(slideData.content_fa, {
        x: 0.5, y: 1.2, w: '90%', h: 2.5, fontSize: settings.fontSize, fontFace: settings.farsiFont, color: theme.bodyColor, lineSpacing: settings.fontSize + 8,
      });
    }
    if (slideData.key_points_fa && slideData.key_points_fa.length > 0) {
      slide.addText(
        slideData.key_points_fa.map((point) => ({ text: point, options: { breakLine: true } })),
        {
          x: 0.7, y: 3.8, w: '85%', h: 3, fontSize: settings.fontSize - 2, fontFace: settings.farsiFont, color: theme.bodyColor, bullet: true, lineSpacing: settings.fontSize + 6,
        }
      );
    }
  }
  return pres.write({ outputType: 'blob' }) as Promise<any> as Promise<Blob>;
}
async function generatePresenterVersion(slides: TranslatedSlideData[], settings: BackendGenerationSettings): Promise<Blob> {
  const pres = new PptxGenJS();
  pres.layout = 'LAYOUT_16x9';
  for (const slideData of slides) {
    const slide = pres.addSlide();
    slide.background = { color: 'FFFFFF' };
    slide.addText(slideData.title_fa, {
      x: 0.5, y: 0.25, w: '90%', h: 1, fontSize: 32, fontFace: settings.farsiFont, bold: true, color: '000000',
    });
    const contentParts = [];
    if (slideData.content_fa) contentParts.push(slideData.content_fa);
    if (slideData.key_points_fa) contentParts.push(...slideData.key_points_fa.map(p => `• ${p}`));
    slide.addText(contentParts.join('\n\n'), {
      x: 0.5, y: 1.5, w: '90%', h: 5.5, fontSize: 20, fontFace: settings.farsiFont, color: '333333',
    });
    const notes = `
SPEAKER NOTES FOR: "${slideData.title_fa}"
---
Main Point (Farsi):
${slideData.content_fa}
Key Talking Points (Farsi):
${slideData.key_points_fa.map((p) => `• ${p}`).join('\n')}
---
ORIGINAL ENGLISH SUMMARY:
Title: ${slideData.title_en}
Content: ${slideData.content_en}
Key Points:
${slideData.key_points_en.map((p) => `• ${p}`).join('\n')}
---
Generated by SlideCraft AI
    `;
    slide.addNotes(notes);
  }
  return pres.write({ outputType: 'blob' }) as Promise<any> as Promise<Blob>;
}
function createSummarizationPrompt(text: string, settings: BackendGenerationSettings): string {
  const summaryRatios = { low: 0.3, medium: 0.5, high: 0.7 };
  const ratio = summaryRatios[settings.summarizationLevel];
  return `
You are an expert academic researcher. Summarize the following scientific article text and structure it for a PowerPoint presentation.
**Article Name:** ${settings.paperName}
**Target Number of Slides:** ${settings.numSlides}
**Summarization Detail Level:** ${settings.summarizationLevel} (Summarize to approx. ${ratio * 100}% of original content)
**Instructions:**
1. Read the article text.
2. Summarize the content in ENGLISH, maintaining scientific accuracy.
3. Divide the summary into ${settings.numSlides} logical sections for slides.
4. For each slide, provide a concise title, the main content body, and 3-5 bullet points (key_points).
5. Return the output as a single, valid JSON object. Do not include any text or markdown formatting before or after the JSON object.
**JSON Output Format:**
{
  "slides": [
    {
      "slide_number": 1,
      "title": "English Slide Title",
      "content": "Summarized English content for this slide.",
      "key_points": ["English Key point 1", "English Key point 2", "English Key point 3"]
    }
  ]
}
**Article Text (first 30k chars):**
---
${text.substring(0, 30000)}
---
`;
}
function createTranslationPrompt(englishSummary: string): string {
  return `
You are a professional academic translator specializing in scientific papers. Translate the following JSON object containing presentation slide content from English to Farsi.
**Instructions:**
1.  Translate the 'title', 'content', and each string in the 'key_points' array for every slide object.
2.  Maintain the exact JSON structure.
3.  Ensure the translation is accurate, professional, and suitable for an academic audience.
4.  Return only the translated, valid JSON object. Do not add any extra text or markdown.
**English JSON Input:**
${englishSummary}
**Farsi JSON Output Format:**
{
  "slides": [
    {
      "slide_number": 1,
      "title": "عنوان اسلاید به فارسی",
      "content": "محتوای خلاصه ش��ه به فارسی برای این اسلاید.",
      "key_points": ["نکته کلیدی ۱ به فارسی", "نکته کلیدی �� به فارسی", "نکته کلیدی ۳ به فارسی"]
    }
  ]
}
`;
}
async function callGoogleAI(prompt: string, apiKey: string, model: string) {
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      response_mime_type: "application/json",
      temperature: 0.5,
    },
  };
  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!response.ok) {
    const errorData: any = await response.json().catch(() => ({ error: { message: `Google AI API responded with status: ${response.status}` } }));
    let message = errorData.error?.message || `Google AI API responded with status: ${response.status}`;
    // Clean up common prefixes from Google API errors for better readability
    message = message.replace(/^\[.*?\]\s*/, '');
    throw new Error(message);
  }
  const responseData: any = await response.json();
  const aiContent = responseData.candidates?.[0]?.content?.parts?.[0]?.text;
  if (!aiContent) throw new Error('AI returned an empty or invalid response.');
  return aiContent;
}
export async function generatePresentation(formData: FormData, env: Env, apiKey: string, model: string) {
  try {
    const file = formData.get('pdfFile') as File;
    const settings: BackendGenerationSettings = {
      paperName: formData.get('paperName') as string,
      numSlides: Number(formData.get('numSlides')),
      summarizationLevel: formData.get('summarizationLevel') as 'low' | 'medium' | 'high',
      farsiFont: formData.get('farsiFont') as any,
      englishFont: formData.get('englishFont') as any,
      fontSize: Number(formData.get('fontSize')),
      colorTheme: formData.get('colorTheme') as any,
      selectedModel: model,
    };
    if (!file) throw new Error('PDF file is missing.');
    const { text: extractedText, numPages } = await extractPdfData(file);
    // Step 1: Summarize in English
    const summarizationPrompt = createSummarizationPrompt(extractedText, settings);
    const englishSummaryContent = await callGoogleAI(summarizationPrompt, apiKey, model);
    const englishData = JSON.parse(englishSummaryContent) as { slides: SlideData[] };
    if (!englishData.slides || !Array.isArray(englishData.slides)) {
      throw new Error('AI returned summary data in an invalid format.');
    }
    // Step 2: Translate to Farsi
    const translationPrompt = createTranslationPrompt(englishSummaryContent);
    const farsiSummaryContent = await callGoogleAI(translationPrompt, apiKey, model);
    const farsiData = JSON.parse(farsiSummaryContent) as { slides: SlideData[] };
     if (!farsiData.slides || !Array.isArray(farsiData.slides) || farsiData.slides.length !== englishData.slides.length) {
      throw new Error('AI returned translation data in an invalid format or with mismatched slide count.');
    }
    // Combine English and Farsi data
    const combinedSlides: TranslatedSlideData[] = englishData.slides.map((engSlide, index) => ({
        title_en: engSlide.title,
        content_en: engSlide.content,
        key_points_en: engSlide.key_points,
        title_fa: farsiData.slides[index].title,
        content_fa: farsiData.slides[index].content,
        key_points_fa: farsiData.slides[index].key_points,
    }));
    const [presentationBlob, presenterBlob] = await Promise.all([
      generatePresentationVersion(combinedSlides, settings),
      generatePresenterVersion(combinedSlides, settings),
    ]);
    const generationResult = {
      statistics: {
        source: settings.paperName,
        field: 'AI Detected Field',
        pdfPages: numPages,
        slides: combinedSlides.length,
        summaryLevel: `${settings.summarizationLevel} (${{ low: '30%', medium: '50%', high: '70%' }[settings.summarizationLevel]})`,
        duration: 'N/A',
        modelUsed: settings.selectedModel,
      },
      presentationBlob,
      presenterBlob,
      filename: settings.paperName.replace(/[^a-z0-9]/gi, '_').toLowerCase()
    };
    return { success: true, data: generationResult };
  } catch (error) {
    console.error('Error in presentation generation:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return { success: false, error: `Generation failed: ${errorMessage}` };
  }
}